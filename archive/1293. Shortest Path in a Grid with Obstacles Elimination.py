import collections


class Solution:
    def shortestPath(self, grid: list, k: int) -> int:
        M, N = len(grid), len(grid[0])

        if k >= M - 1 + N - 1:
            return M - 1 + N - 1
        q = collections.deque()
        visited =set()
        q.append((0, 0, 0, 0))
        visited.add((0, 0, 0))
        while q:
            x, y, eli, steps = q.popleft()
            if (x, y) == (M - 1, N - 1):
                return steps
            for dx, dy in ((-1, 0), (1, 0), (0, -1), (0, 1)):
                x1, y1 = x + dx, y + dy
                if 0 <= x1 < M and 0 <= y1 < N:
                    if grid[x1][y1] == 0:
                        if (x1, y1, eli) not in visited:
                            q.append((x1, y1, eli, steps + 1))
                            visited.add((x1, y1, eli))
                    elif eli < k and (x1, y1, eli + 1) not in visited:
                            q.append((x1, y1, eli + 1, steps + 1))
                            visited.add((x1, y1, eli+1))
        return -1

grid=[[0,1,0,0,1,1,1,0,1,1,0,0,1,1,1,0,1],[0,1,0,0,0,0,0,1,0,0,1,0,0,1,0,1,1],[1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,1,1],[0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,0,1],[1,0,1,0,0,1,0,0,1,0,1,0,0,0,1,1,1],[0,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0],[1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,1],[0,1,1,1,1,0,0,1,0,1,1,0,0,1,1,1,0],[1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1],[0,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,0],[0,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,1],[1,0,1,0,1,0,1,0,0,0,1,1,1,0,0,0,1],[1,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0],[0,0,1,1,1,1,1,1,0,1,0,0,1,1,0,1,1],[0,0,1,0,1,1,0,0,0,1,0,1,0,0,0,0,0],[0,1,1,0,1,1,0,1,1,1,0,1,0,1,1,1,1],[0,0,0,1,1,1,1,1,0,0,1,1,1,0,1,0,1],[0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,0],[0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0],[0,0,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0],[0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,1],[1,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,1],[1,1,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1],[1,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0]]
k=38
print(Solution().shortestPath(grid,k))